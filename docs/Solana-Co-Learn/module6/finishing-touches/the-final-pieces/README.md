---
sidebar_position: 106
sidebar_label: ğŸš¶â€ æœ€åçš„ä½œå“
sidebar_class_name: green
---

# ğŸš¶â€ æœ€åçš„ä½œå“


## æ¦‚è¿°

è¿™æ˜¯æœ€åçš„å†²åˆºï¼æ­å–œä½ åˆ°è¾¾è¿™é‡Œï¼å¯¹æ¯ä¸ªäººæ¥è¯´ï¼Œè¿™éƒ½æ˜¯ä¸€æ®µç–¯ç‹‚çš„æ—…ç¨‹ã€‚æ— è®ºä½ çš„NFTé¡¹ç›®å¤„äºä»€ä¹ˆçŠ¶æ€ï¼Œéƒ½è¦æ·±å‘¼å¸ï¼Œç»™è‡ªå·±é¼“åŠ±ã€‚ä½ çœŸæ£’ï¼

ç°åœ¨ï¼Œè¯„ä¼°ä¸€ä¸‹ä½ ç›®å‰æ‰€æ‹¥æœ‰çš„ï¼Œå¹¶è€ƒè™‘ä¸€ä¸‹ä¸ºäº†è®©ä½ çš„é¡¹ç›®å‡†å¤‡å¥½è¿›è¡Œäº¤ä»˜ï¼Œä½ å¯ä»¥åšçš„æœ€å°‘å·¥ä½œé‡ã€‚å¦‚æœè¿™æ„å‘³ç€æš‚æ—¶è·³è¿‡`Switchboard`çš„äº‹æƒ…ï¼Œé‚£å°±è¿™æ ·å§ã€‚

ç°åœ¨æ˜¯æ—¶å€™å°†æ‚¨çš„ç”¨æˆ·ç•Œé¢ä¸æ‚¨çš„æˆ˜åˆ©å“ç®±å’Œè£…å¤‡æŒ‡ç¤ºè¿æ¥èµ·æ¥ï¼Œç„¶åè¿›è¡Œä»»ä½•æœ€åçš„æ¶¦é¥°å·¥ä½œï¼Œç„¶åå°†è¿™ä¸ªä¸œè¥¿å‘è´§ï¼

åœ¨æˆ‘ä»¬çš„æƒ…å†µä¸‹ï¼Œè¿™æ„å‘³ç€ï¼š

- ç”¨ `GearItem` å’Œ `Lootbox` ç»„ä»¶æ›¿æ¢æˆ‘ä»¬åœ¨UIçš„é‚£éƒ¨åˆ†ä½¿ç”¨çš„æ¨¡æ‹Ÿ `ItemBox`
- æ·»åŠ ä¸€ä¸ª`instructions.ts`æ–‡ä»¶ï¼Œåœ¨è¿™ä¸ªæ–‡ä»¶ä¸­æˆ‘ä»¬åˆ›å»ºå‡½æ•°æ¥ï¼š
- åˆ›å»ºæ‰€æœ‰å¿…éœ€çš„æŒ‡ä»¤æ¥åˆå§‹åŒ–æˆ‘ä»¬çš„æˆ˜åˆ©å“ç®±å’Œäº¤æ¢æœº
- åˆ›å»ºæ‰“å¼€æˆ˜åˆ©å“ç®±æ‰€éœ€çš„æ‰€æœ‰è¯´æ˜
- æ³¨æ„ï¼šè¿™ä¸ªæœ‰ç‚¹æ¿€çƒˆï¼Œå“ˆå“ˆ - çœ‹çœ‹æˆ‘ä»¬çš„è§£å†³æ–¹æ¡ˆä»£ç ï¼Œä½†ä¹Ÿè¯•è¯•è‡ªå·±çš„æ–¹æ³•
- è¿›è¡Œå¤§é‡çš„è°ƒè¯•å’Œä¼˜åŒ–

è¯´å®è¯ï¼Œè¿™ä¸ªåˆ—è¡¨è¿˜æœ‰å¾ˆå¤šã€‚æˆ‘ä»¬æ·»åŠ äº†å¾ˆå¤šç»„ä»¶ï¼Œä»¥ç¡®ä¿åœ¨äº¤æ˜“å’Œé“¾ä¸Šå˜åŒ–ä¹‹åçŠ¶æ€å¾—åˆ°æ›´æ–°ã€‚å³ä¾¿å¦‚æ­¤ï¼Œå®ƒè¿˜ä¸å®Œç¾ã€‚æ€»æ˜¯æœ‰æ›´å¤šçš„ç©ºé—´å¯ä»¥åšå¾—æ›´å¥½ï¼Œä½†ä¸è¦è®©å®Œç¾ä¸»ä¹‰æˆä¸ºä½ çš„æ•Œäººã€‚å°½åŠ›è€Œä¸ºï¼Œç„¶åå‘è´§ï¼

## è§£å†³æ–¹æ¡ˆä»£ç 

æˆ‘ä»¬çš„è§£å†³æ–¹æ¡ˆä½äº[Buildoorsä»£ç åº“](https://github.com/CreatorsDAO/buildspace-buildoors/tree/solution-lootboxes)çš„ `solution-lootboxes` åˆ†æ”¯ä¸Šã€‚åœ¨é‚£é‡Œæœ‰ä¸€äº›æäº¤ä½¿å…¶ä¸æ‚¨ä¸Šæ¬¡çœ‹åˆ°çš„ä¸åŒï¼Œæ‰€ä»¥å¦‚æœæ‚¨æƒ³æŸ¥çœ‹æ‰€æœ‰æ›´æ”¹ï¼Œè¯·ç¡®ä¿ä»ä¸Šå‘¨çš„[åˆ†æ”¯æŸ¥çœ‹å·®å¼‚](https://github.com/CreatorsDAO/buildspace-buildoors/compare/solution-core-5...solution-lootboxes)ã€‚

æœ‰ä¸€äº›æŒ‡å—ï¼Œä½†ä½ å¯ä»¥å…ˆè‡ªå·±å¼€å§‹ã€‚ç¥ä½ å¥½è¿ï¼

## æ¦‚è¿°

æœ€åä¸€ä¸ªé¡¹ç›®æ‰€éœ€çš„ä¸€åˆ‡éƒ½åœ¨ä¸Šä¸€è¯¾ä¸­ã€‚ä»ç°åœ¨å¼€å§‹ï¼Œåªæœ‰ä½ å’Œè¿™æ®µæ–‡å­—äº†ï¼Œå®è´ã€‚æˆ‘ä»¬å¼€å§‹å§ï¼

è¿™å°±æ˜¯æœ€ç»ˆäº§å“çš„æ ·å­ï¼Œè¿™ä¸ªæˆªå›¾æ˜¯è¿™ä¸ªé¡¹ç›®çš„ä¸€ä¸ªå·¥ä½œç¤ºä¾‹ã€‚

![](./img/YF5XxJr.png)

åœ¨è¿™ä¸ªéƒ¨åˆ†ï¼Œæˆ‘ä»¬å°†ä¸“æ³¨äºä½¿æˆ˜åˆ©å“ç®±å’Œè£…å¤‡åŠŸèƒ½æ­£å¸¸å·¥ä½œã€‚æœ€ç»ˆçš„ä»£ç å¯èƒ½éœ€è¦ä¸€äº›æ¶¦è‰²ï¼Œå¹¶ä¸”è¿˜æœ‰ä¸€äº›å°çš„é”™è¯¯éœ€è¦è§£å†³ï¼Œä½ å¯ä»¥åœ¨å‘è´§ä¹‹å‰éšæ„å¤„ç†ã€‚

å‡ ç‚¹æ³¨æ„äº‹é¡¹ï¼Œè¯·ç¡®ä¿æ¯æ¬¡æ›´æ”¹ç¨‹åºæ—¶éƒ½å¤åˆ¶å¹¶ç²˜è´´æ–°çš„IDLã€‚ä»”ç»†æ£€æŸ¥æ‚¨çš„React hookså’Œä¾èµ–é¡¹ã€‚å°½å¯èƒ½å°†æ‰€æœ‰å†…å®¹åˆ†è§£ä¸ºå°å—ã€‚

æˆ‘ä»¬ç°åœ¨è¦æ·±å…¥ç ”ç©¶ä¸€äº›ä»£ç çš„å˜åŠ¨ã€‚è®©æˆ‘ä»¬å¼€å§‹`/components/WorkspaceProvider.tsx`å§ã€‚

åªæœ‰ä¸€äº›å°çš„å˜åŠ¨ï¼Œä¸»è¦æ˜¯ä¸ºäº†åŠ å…¥`switchboard program.`ã€‚

æœ‰ä¸€ä¸ªæ–°çš„`useState`ã€‚

```tsx
const [switchboardProgram, setProgramSwitchboard] = useState<any>()
```

ç„¶åæˆ‘ä»¬åŠ è½½`switchboard program`ï¼Œå¹¶ä½¿ç”¨`useEffect`è®¾ç½®`the program switchboard`ï¼Œè¿™æ ·æˆ‘ä»¬çš„å·¥ä½œåŒºå§‹ç»ˆå¯ä»¥åŠæ—¶æ›´æ–°æˆ‘ä»¬æ‰€éœ€çš„æ‰€æœ‰ç¨‹åºã€‚é™¤éä½ æ˜¯Reactä¸“å®¶ï¼Œå¦åˆ™è¿™å¯èƒ½ä¼šæœ‰äº›æŒ‘æˆ˜ï¼Œæ‰€ä»¥è¯·éšæ„æ·±å…¥å‚è€ƒè¿™æ®µä»£ç ã€‚

```tsx
async function program() {
    let response = await loadSwitchboardProgram(
      "devnet",
      connection,
      ((provider as AnchorProvider).wallet as AnchorWallet).payer
    )
    return response
  }

useEffect(() => {
    program().then((result) => {
      setProgramSwitchboard(result)
      console.log("result", result)
    })
  }, [connection])
```

å¥½çš„ï¼Œæ¥ä¸‹æ¥æˆ‘ä»¬è¿›å…¥ `instructions.ts` æ–‡ä»¶å¤¹ä¸­çš„ `utils` æ–‡ä»¶ï¼Œè¿™æ˜¯ä¸€ä¸ªæ–°æ–‡ä»¶ã€‚è¿™é‡Œæœ‰ä¸¤ä¸ªå…¬å…±å‡½æ•°ï¼Œåˆ†åˆ«æ˜¯ `createOpenLootboxInstructions` æŒ‡ä»¤å’Œ `createInitSwitchboardInstructions` æŒ‡ä»¤ã€‚åè€…ç”¨äºæ‰“åŒ…äº¤æ¢æœºç¨‹åºçš„åˆå§‹åŒ–å†…å®¹ï¼Œå¹¶åˆå§‹åŒ–æŠ½å¥–ç®±ç¨‹åºä¸­çš„ç”¨æˆ·ã€‚

```tsx
export async function createOpenLootboxInstructions(
  connection: Connection,
  stakingProgram: Program<AnchorNftStaking>,
  switchboardProgram: SwitchboardProgram,
  lootboxProgram: Program<LootboxProgram>,
  userPubkey: PublicKey,
  nftTokenAccount: PublicKey,
  box: number
): Promise<TransactionInstruction[]> {
  const [userStatePda] = PublicKey.findProgramAddressSync(
    [userPubkey.toBytes()],
    lootboxProgram.programId
  )

  const state = await lootboxProgram.account.userState.fetch(userStatePda)

  const accounts = await getAccountsAndData(
    lootboxProgram,
    switchboardProgram,
    userPubkey,
    state.vrf
  )

  return await createAllOpenLootboxInstructions(
    connection,
    stakingProgram,
    lootboxProgram,
    switchboardProgram,
    accounts,
    nftTokenAccount,
    box
  )
}
```

è¿›ä¸€æ­¥å¾€ä¸‹ï¼Œæœ‰ä¸€ä¸ª `getAccountsAndData` å‡½æ•°ï¼Œå®ƒæ¥å—å››ä¸ªå­—æ®µï¼Œæ­£å¦‚ä½ æ‰€è§ï¼Œå¯¹äºæœ€åä¸€ä¸ªå­—æ®µï¼Œä½ éœ€è¦äº‹å…ˆç”Ÿæˆæˆ–è·å–`vrf`è´¦æˆ·ã€‚è¿™ä¸ªå‡½æ•°çš„ä½œç”¨æ˜¯è·å–ä¸€äº›è´¦æˆ·ã€å¢åŠ å’Œå…¶ä»–æ•°æ®ï¼Œå°†å®ƒä»¬æ‰“åŒ…èµ·æ¥ï¼Œå¹¶ä½œä¸ºä¸€ä¸ªå¯¹è±¡è¿”å›ã€‚

```tsx
async function getAccountsAndData(
  lootboxProgram: Program<LootboxProgram>,
  switchboardProgram: SwitchboardProgram,
  userPubkey: PublicKey,
  vrfAccount: PublicKey
): Promise<AccountsAndDataSuperset> {
  const [userStatePda] = PublicKey.findProgramAddressSync(
    [userPubkey.toBytes()],
    lootboxProgram.programId
  )

  // required switchboard accoount
  const [programStateAccount, stateBump] =
    ProgramStateAccount.fromSeed(switchboardProgram)

  // required switchboard accoount
  const queueAccount = new OracleQueueAccount({
    program: switchboardProgram,
    // devnet permissionless queue
    publicKey: new PublicKey("F8ce7MsckeZAbAGmxjJNetxYXQa9mKr9nnrC3qKubyYy"),
  })

  // required switchboard accoount
  const queueState = await queueAccount.loadData()
  // wrapped SOL is used to pay for switchboard VRF requests
  const wrappedSOLMint = await queueAccount.loadMint()

  // required switchboard accoount
  const [permissionAccount, permissionBump] = PermissionAccount.fromSeed(
    switchboardProgram,
    queueState.authority,
    queueAccount.publicKey,
    vrfAccount
  )

  // required switchboard accoount
  // escrow wrapped SOL token account owned by the VRF account we will initialize
  const escrow = await spl.getAssociatedTokenAddress(
    wrappedSOLMint.address,
    vrfAccount,
    true
  )

  const size = switchboardProgram.account.vrfAccountData.size

  return {
    userPubkey: userPubkey,
    userStatePda: userStatePda,
    vrfAccount: vrfAccount,
    escrow: escrow,
    wrappedSOLMint: wrappedSOLMint,
    programStateAccount: programStateAccount,
    stateBump: stateBump,
    permissionBump: permissionBump,
    queueAccount: queueAccount,
    queueState: queueState,
    permissionAccount: permissionAccount,
    size: size,
  }
}
```

è¯¥å¯¹è±¡åœ¨æ–‡ä»¶åº•éƒ¨è¢«å®šä¹‰ä¸ºä¸€ä¸ªæ¥å£ï¼Œè¿™åªæ˜¯ä¸ºäº†ç¡®ä¿ä½ æ‹¥æœ‰æ‰€éœ€çš„ä¸€åˆ‡ï¼Œå¹¶èƒ½å¤Ÿé€‚å½“åœ°è°ƒç”¨å®ƒä»¬ã€‚è™½ç„¶æ¯ä¸ªæŒ‡ä»¤ä¸éœ€è¦å¯¹è±¡ä¸­çš„æ¯ä¸ªå­—æ®µï¼Œä½†è¿™å°†ä½¿æ¯ä¸ªæŒ‡ä»¤èƒ½å¤Ÿè½»æ¾åœ°è®¿é—®æ‰€éœ€çš„æ•°æ®ã€‚

```tsx
interface AccountsAndDataSuperset {
  userPubkey: PublicKey
  userStatePda: PublicKey
  vrfAccount: PublicKey
  escrow: PublicKey
  wrappedSOLMint: spl.Mint
  programStateAccount: ProgramStateAccount
  stateBump: number
  permissionBump: number
  queueAccount: OracleQueueAccount
  queueState: any
  permissionAccount: PermissionAccount
  size: number
}
```

è®©æˆ‘ä»¬æ·±å…¥äº†è§£ `createInitSwitchboardInstructions` ã€‚å®ƒé¦–å…ˆç”Ÿæˆä¸€ä¸ª`vrf`å¯†é’¥å¯¹ï¼Œç„¶åè°ƒç”¨ `getAccountsAndData` æ¥è·å–æˆ‘ä»¬æ‰€éœ€çš„æ‰€æœ‰è´¦æˆ·ã€‚ç„¶åï¼Œé€šè¿‡ `initSwitchboardLootboxUser` ï¼Œå®ƒç»„è£…æŒ‡ä»¤ã€‚ç„¶åè¿”å›æŒ‡ä»¤ï¼Œä»¥åŠç”¨äºç­¾åçš„`vrf`å¯†é’¥å¯¹ã€‚

```tsx
export async function createInitSwitchboardInstructions(
  switchboardProgram: SwitchboardProgram,
  lootboxProgram: Program<LootboxProgram>,
  userPubkey: PublicKey
): Promise<{
  instructions: Array<TransactionInstruction>
  vrfKeypair: Keypair
}> {
  const vrfKeypair = Keypair.generate()

  const accounts = await getAccountsAndData(
    lootboxProgram,
    switchboardProgram,
    userPubkey,
    vrfKeypair.publicKey
  )

  const initInstructions = await initSwitchboardLootboxUser(
    switchboardProgram,
    lootboxProgram,
    accounts,
    vrfKeypair
  )

  return { instructions: initInstructions, vrfKeypair: vrfKeypair }
}
```

å…³äº `initSwitchboardLootboxUser` ï¼Œæˆ‘ä»¬é¦–å…ˆè·å¾—ä¸€ä¸ª`PDA`å’Œ`state bump`ã€‚

```tsx
async function initSwitchboardLootboxUser(
  switchboardProgram: SwitchboardProgram,
  lootboxProgram: Program<LootboxProgram>,
  accountsAndData: AccountsAndDataSuperset,
  vrfKeypair: Keypair
): Promise<Array<TransactionInstruction>> {
  // lootbox account PDA
  const [lootboxPointerPda] = await PublicKey.findProgramAddress(
    [Buffer.from("lootbox"), accountsAndData.userPubkey.toBytes()],
    lootboxProgram.programId
  )

  const stateBump = accountsAndData.stateBump
```

ç„¶åæˆ‘ä»¬å¼€å§‹ç»„è£…ä¸€ç³»åˆ—çš„æŒ‡ä»¤ã€‚é¦–å…ˆï¼Œæˆ‘ä»¬éœ€è¦åšçš„æ˜¯åˆ›å»ºä¸€ä¸ªä¸æ‰˜ç®¡ç›¸å…³çš„ä»¤ç‰Œè´¦æˆ·ï¼Œç”±vrfå¯†é’¥å¯¹æ‹¥æœ‰ã€‚

```tsx
const txnIxns: TransactionInstruction[] = [
    // create escrow ATA owned by VRF account
    spl.createAssociatedTokenAccountInstruction(
      accountsAndData.userPubkey,
      accountsAndData.escrow,
      vrfKeypair.publicKey,
      accountsAndData.wrappedSOLMint.address
    ),
```

æ¥ä¸‹æ¥æ˜¯è®¾ç½®æƒé™æŒ‡ä»¤ã€‚

```tsx
// transfer escrow ATA owner to switchboard programStateAccount
    spl.createSetAuthorityInstruction(
      accountsAndData.escrow,
      vrfKeypair.publicKey,
      spl.AuthorityType.AccountOwner,
      accountsAndData.programStateAccount.publicKey,
      [vrfKeypair]
    ),

```

ç„¶åæˆ‘ä»¬è°ƒç”¨`create account`æ¥åˆ›å»ºvrfè´¦æˆ·ã€‚

```tsx
// request system program to create new account using newly generated keypair for VRF account
   SystemProgram.createAccount({
     fromPubkey: accountsAndData.userPubkey,
     newAccountPubkey: vrfKeypair.publicKey,
     space: accountsAndData.size,
     lamports:
       await switchboardProgram.provider.connection.getMinimumBalanceForRentExemption(
         accountsAndData.size
       ),
     programId: switchboardProgram.programId,
   }),
```

ç„¶åæˆ‘ä»¬ä½¿ç”¨`switchboard program `æ–¹æ³•è¿›è¡Œ`vrf`åˆå§‹åŒ–ï¼Œå…¶ä¸­æˆ‘ä»¬æä¾›äº†æ¶ˆè€—éšæœºæ€§å›è°ƒå‡½æ•°ã€‚

```tsx
// initialize new VRF account, included the callback CPI into lootbox program as instruction data
await switchboardProgram.methods
  .vrfInit({
    stateBump,
    callback: {
      programId: lootboxProgram.programId,
      accounts: [
        {
          pubkey: accountsAndData.userStatePda,
          isSigner: false,
          isWritable: true,
        },
        {
          pubkey: vrfKeypair.publicKey,
          isSigner: false,
          isWritable: false,
        },
        { pubkey: lootboxPointerPda, isSigner: false, isWritable: true },
        {
          pubkey: accountsAndData.userPubkey,
          isSigner: false,
          isWritable: false,
        },
      ],
      ixData: new BorshInstructionCoder(lootboxProgram.idl).encode(
        "consumeRandomness",
        ""
      ),
    },
  })
  .accounts({
    vrf: vrfKeypair.publicKey,
    escrow: accountsAndData.escrow,
    authority: accountsAndData.userStatePda,
    oracleQueue: accountsAndData.queueAccount.publicKey,
    programState: accountsAndData.programStateAccount.publicKey,
    tokenProgram: spl.TOKEN_PROGRAM_ID,
  })
  .instruction(),
// initialize switchboard permission account, required account
```
æ¥ä¸‹æ¥æˆ‘ä»¬ä½¿ç”¨`switchboard`æ¥è°ƒç”¨æƒé™åˆå§‹åŒ–ã€‚

```tsx
await switchboardProgram.methods
      .permissionInit({})
      .accounts({
        permission: accountsAndData.permissionAccount.publicKey,
        authority: accountsAndData.queueState.authority,
        granter: accountsAndData.queueAccount.publicKey,
        grantee: vrfKeypair.publicKey,
        payer: accountsAndData.userPubkey,
        systemProgram: SystemProgram.programId,
      })
      .instruction(),
```

æœ€åï¼Œæˆ‘ä»¬å°†æˆ‘ä»¬çš„æˆ˜åˆ©å“ç®±è®¡åˆ’ç§°ä¸º`init user`ï¼Œå¹¶è¿”å›æŒ‡ç¤ºï¼Œè¿™å°†ç”±è°ƒç”¨è€…æ‰“åŒ…æˆäº¤æ˜“ã€‚

```tsx
await lootboxProgram.methods
      .initUser({
        switchboardStateBump: accountsAndData.stateBump,
        vrfPermissionBump: accountsAndData.permissionBump,
      })
      .accounts({
        // state: userStatePDA,
        vrf: vrfKeypair.publicKey,
        // payer: publicKey,
        // systemProgram: anchor.web3.SystemProgram.programId,
      })
      .instruction(),
  ]

  return txnIxns
}
```

æœ€åï¼Œè®©æˆ‘ä»¬å›é¡¾ä¸€ä¸‹ `createOpenLootboxInstructions` ã€‚é¦–å…ˆï¼Œæˆ‘ä»¬è·å–ç”¨æˆ·çŠ¶æ€`PDA`ï¼Œæˆ‘ä»¬å¿…é¡»å®é™…è·å–è¯¥è´¦æˆ·ï¼Œä»¥ä¾¿æˆ‘ä»¬å¯ä»¥ä»ä¸­æå–`vrf`å¯†é’¥å¯¹ã€‚

```tsx
export async function createOpenLootboxInstructions(
  connection: Connection,
  stakingProgram: Program<AnchorNftStaking>,
  switchboardProgram: SwitchboardProgram,
  lootboxProgram: Program<LootboxProgram>,
  userPubkey: PublicKey,
  nftTokenAccount: PublicKey,
  box: number
): Promise<TransactionInstruction[]> {
  const [userStatePda] = PublicKey.findProgramAddressSync(
    [userPubkey.toBytes()],
    lootboxProgram.programId
  )

  const state = await lootboxProgram.account.userState.fetch(userStatePda)
```

åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬ç§°ä¹‹ä¸º `getAccountsAndData` æ¥è·å–æˆ‘ä»¬æ‰€éœ€çš„æ‰€æœ‰è´¦æˆ·ã€‚æ¥ä¸‹æ¥æ˜¯ `createAllOpenLootboxInstructions` ï¼Œæˆ‘ä»¬å°†æ·±å…¥æ¢è®¨ã€‚

```tsx
const accounts = await getAccountsAndData(
    lootboxProgram,
    switchboardProgram,
    userPubkey,
    state.vrf
  )

  return await createAllOpenLootboxInstructions(
    connection,
    stakingProgram,
    lootboxProgram,
    switchboardProgram,
    accounts,
    nftTokenAccount,
    box
  )
}
```
æˆ‘ä»¬è·å¾—äº†åŒ…è£…çš„ä»£å¸è´¦æˆ·ï¼Œå…¶ä¸­åŒ…å«äº†åŒ…è£…çš„SOLï¼Œå› ä¸ºè¿™æ˜¯æˆ‘ä»¬ç”¨æ¥æ”¯ä»˜è¯·æ±‚éšæœºæ•°çš„å¿…éœ€å“ã€‚



```tsx
async function createAllOpenLootboxInstructions(
  connection: Connection,
  stakingProgram: Program<AnchorNftStaking>,
  lootboxProgram: Program<LootboxProgram>,
  switchboardProgram: SwitchboardProgram,
  accountsAndData: AccountsAndDataSuperset,
  nftTokenAccount: PublicKey,
  box: number
): Promise<TransactionInstruction[]> {
  // user Wrapped SOL token account
  // wSOL amount is then transferred to escrow account to pay switchboard oracle for VRF request
  const wrappedTokenAccount = await spl.getAssociatedTokenAddress(
    accountsAndData.wrappedSOLMint.address,
    accountsAndData.userPubkey
  )
```

æ¥ä¸‹æ¥æˆ‘ä»¬è·å¾—ä¸`BLD`ç›¸å…³çš„ `stakeTokenAccount` ï¼Œå› æ­¤æ‚¨å¯ä»¥ä½¿ç”¨`BLD`ä»£å¸æ¥æ¢å–å¼€å¯æˆ˜åˆ©å“ç®±ã€‚ç„¶åæ˜¯è´¨æŠ¼è´¦æˆ·ï¼Œä»¥ç¡®ä¿æ‚¨é€šè¿‡è´¨æŠ¼è·å¾—è¶³å¤Ÿçš„`BLD`æ¥å¼€å¯æˆ˜åˆ©å“ç®±ã€‚

```tsx
// user BLD token account, used to pay BLD tokens to call the request randomness instruction on Lootbox program
  const stakeTokenAccount = await spl.getAssociatedTokenAddress(
    STAKE_MINT,
    accountsAndData.userPubkey
  )

  const [stakeAccount] = PublicKey.findProgramAddressSync(
    [accountsAndData.userPubkey.toBytes(), nftTokenAccount.toBuffer()],
    stakingProgram.programId
  )
```

è¿™é‡Œå¼€å§‹ç»„è£…è¯´æ˜ã€‚å¦‚æœæ²¡æœ‰å°è£…çš„ä»¤ç‰Œè´¦æˆ·ï¼Œæˆ‘ä»¬ä¼šæ·»åŠ ä¸€ä¸ªåˆ›å»ºå®ƒçš„æŒ‡ä»¤ã€‚

```tsx
let instructions: TransactionInstruction[] = []
  // check if a wrapped SOL token account exists, if not add instruction to create one
  const account = await connection.getAccountInfo(wrappedTokenAccount)
  if (!account) {
    instructions.push(
      spl.createAssociatedTokenAccountInstruction(
        accountsAndData.userPubkey,
        wrappedTokenAccount,
        accountsAndData.userPubkey,
        accountsAndData.wrappedSOLMint.address
      )
    )
  }
```

ç„¶åæˆ‘ä»¬æ¨é€ä¸€ä¸ªè½¬è´¦æŒ‡ä»¤ï¼Œå°†SOLè½¬ç§»åˆ°`wrapped SOL`ã€‚ç„¶åæ˜¯ä¸€ä¸ªåŒæ­¥`wrapped SOL`ä½™é¢çš„æŒ‡ä»¤ã€‚

```tsx
// transfer SOL to user's own wSOL token account
 instructions.push(
   SystemProgram.transfer({
     fromPubkey: accountsAndData.userPubkey,
     toPubkey: wrappedTokenAccount,
     lamports: 0.002 * LAMPORTS_PER_SOL,
   })
 )
 // sync wrapped SOL balance
 instructions.push(spl.createSyncNativeInstruction(wrappedTokenAccount))
```

æœ€åï¼Œæˆ‘ä»¬åˆ¶ä½œå¹¶è¿”å›äº†æ‰“å¼€æˆ˜åˆ©å“ç®±çš„è¯´æ˜ä¹¦ï¼Œè¿™æ ·å‘¼å«è€…å°±å¯ä»¥å°†å®ƒä»¬æ‰“åŒ…å¹¶å‘é€å‡ºå»ã€‚

```tsx
// Lootbox program request randomness instruction
  instructions.push(
    await lootboxProgram.methods
      .openLootbox(new BN(box))
      .accounts({
        user: accountsAndData.userPubkey,
        stakeMint: STAKE_MINT,
        stakeMintAta: stakeTokenAccount,
        stakeState: stakeAccount,
        state: accountsAndData.userStatePda,
        vrf: accountsAndData.vrfAccount,
        oracleQueue: accountsAndData.queueAccount.publicKey,
        queueAuthority: accountsAndData.queueState.authority,
        dataBuffer: accountsAndData.queueState.dataBuffer,
        permission: accountsAndData.permissionAccount.publicKey,
        escrow: accountsAndData.escrow,
        programState: accountsAndData.programStateAccount.publicKey,
        switchboardProgram: switchboardProgram.programId,
        payerWallet: wrappedTokenAccount,
        recentBlockhashes: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
      })
      .instruction()
  )

  return instructions
}
```

è¿™å°±æ˜¯è¯´æ˜çš„å…¨éƒ¨å†…å®¹ï¼Œè®©æˆ‘ä»¬å»çœ‹çœ‹æ–°çš„æˆ˜åˆ©å“ç®±ç»„ä»¶ï¼Œè¿™äº›è¯´æ˜å°†ä¼šè¢«ç”¨åˆ°é‚£é‡Œã€‚
