---
sidebar_position: 106
sidebar_label: ğŸš¶â€ æœ€åçš„ä½œå“
sidebar_class_name: green
---

# ğŸš¶â€ æœ€ç»ˆä½œå“

## æ¦‚è¿°

ç»ˆäºåˆ°äº†æœ€åçš„å†²åˆºé˜¶æ®µï¼æ­å–œä½ æŠµè¾¾æ­¤åœ°ï¼è¿™å¯¹æ¯ä¸ªäººæ¥è¯´éƒ½æ˜¯ä¸€æ¬¡ä»¤äººæ¿€åŠ¨çš„æ—…ç¨‹ã€‚ä¸è®ºä½ çš„NFTé¡¹ç›®å¤„äºä½•ç§é˜¶æ®µï¼Œéƒ½è¦æ·±å‘¼å¸ï¼Œç»™è‡ªå·±ä¸€ä¸ªèµæ‰¬ï¼Œä½ åšå¾—éå¸¸æ£’ï¼

ç°åœ¨ï¼Œå®¡è§†ä¸€ä¸‹ä½ æ‰‹å¤´çš„æˆæœï¼Œç„¶åæ€è€ƒä¸€ä¸‹ï¼Œä¸ºäº†è®©é¡¹ç›®åšå¥½äº¤ä»˜å‡†å¤‡ï¼Œä½ è‡³å°‘è¿˜éœ€è¦åšäº›ä»€ä¹ˆã€‚å¦‚æœéœ€è¦æš‚æ—¶è·³è¿‡`Switchboard`çš„éƒ¨åˆ†ï¼Œé‚£å°±è¿™æ ·åšã€‚

ç°åœ¨æ˜¯æ—¶å€™æŠŠä½ çš„ç”¨æˆ·ç•Œé¢ä¸æˆ˜åˆ©å“ç®±å’Œè£…å¤‡æŒ‡ç¤ºå™¨è¿æ¥èµ·æ¥ï¼Œå®Œæˆæœ€åçš„ä¿®æ•´å·¥ä½œï¼Œç„¶åäº¤ä»˜è¿™ä¸ªä½œå“ï¼

å…·ä½“æ¥è¯´ï¼Œæˆ‘ä»¬éœ€è¦ï¼š

- ä½¿ç”¨`GearItem`å’Œ`Lootbox`ç»„ä»¶æ›¿æ¢UIä¸­ä½¿ç”¨çš„æ¨¡æ‹Ÿ`ItemBox`ã€‚
- æ·»åŠ ä¸€ä¸ª`instructions.ts`æ–‡ä»¶ï¼Œåœ¨å…¶ä¸­åˆ›å»ºå‡½æ•°æ¥ï¼š
  - åˆ›å»ºåˆå§‹åŒ–æˆ˜åˆ©å“ç®±å’Œäº¤æ¢æœºæ‰€éœ€çš„æ‰€æœ‰æŒ‡ä»¤ã€‚
  - åˆ›å»ºæ‰“å¼€æˆ˜åˆ©å“ç®±æ‰€éœ€çš„æ‰€æœ‰æŒ‡ä»¤ã€‚
  - æ³¨æ„ï¼šè¿™éƒ¨åˆ†å¯èƒ½æœ‰äº›å¤æ‚ - ä½ å¯ä»¥å‚è€ƒæˆ‘ä»¬çš„è§£å†³æ–¹æ¡ˆä»£ç ï¼Œä½†ä¹Ÿä¸å¦¨å°è¯•è‡ªå·±çš„æ–¹æ³•ã€‚
- è¿›è¡Œå¤§é‡çš„è°ƒè¯•å’Œä¼˜åŒ–ã€‚

å¦ç™½è¯´ï¼Œè¿™ä¸ªåˆ—è¡¨å¯èƒ½è¿˜è¿œè¿œä¸å¤Ÿã€‚æˆ‘ä»¬æ·»åŠ äº†è®¸å¤šç»„ä»¶æ¥ç¡®ä¿äº¤æ˜“å’Œé“¾ä¸Šå˜åŒ–åçŠ¶æ€å¾—åˆ°æ›´æ–°ï¼Œä½†å®ƒä»æœ‰ä¸å®Œç¾çš„åœ°æ–¹ã€‚æ€»æœ‰æ›´å¤šçš„ç©ºé—´å¯ä»¥æ”¹è¿›ï¼Œä½†ä¸è¦è®©å®Œç¾ä¸»ä¹‰æˆä¸ºä½ å‰è¿›çš„éšœç¢ã€‚å°½ä½ æ‰€èƒ½ï¼Œç„¶åäº¤ä»˜å§ï¼

## è§£å†³æ–¹æ¡ˆä»£ç 

æˆ‘ä»¬çš„è§£å†³æ–¹æ¡ˆä½äº[Buildoorsä»£ç åº“](https://github.com/all-in-one-solana/buildspace-buildoors/tree/solution-lootboxes)çš„`solution-lootboxes`åˆ†æ”¯ä¸Šã€‚ä¸ä½ ä¸Šæ¬¡æŸ¥çœ‹çš„ä»£ç å¯èƒ½æœ‰äº›è®¸å·®å¼‚ï¼Œå› æ­¤å¦‚æœä½ æƒ³æŸ¥çœ‹æ‰€æœ‰æ›´æ”¹ï¼Œè¯·ç¡®ä¿ä»ä¸Šå‘¨çš„[åˆ†æ”¯æŸ¥çœ‹å·®å¼‚](https://github.com/all-in-one-solana/buildspace-buildoors/compare/solution-core-5...solution-lootboxes)ã€‚

æœ‰ä¸€äº›å¼•å¯¼ï¼Œä½†ä½ å¯ä»¥è‡ªç”±å¼€å§‹ã€‚ç¥ä½ å¥½è¿ï¼

## ä¸‹ä¸€æ­¥

ç°åœ¨ï¼Œæœ€åä¸€ä¸ªé¡¹ç›®æ‰€éœ€çš„ä¸€åˆ‡éƒ½åœ¨ä¸Šä¸€è¯¾ä¸­ã€‚ä»è¿™ä¸€åˆ»èµ·ï¼Œè¿™å°±æ˜¯ä½ å’Œæ–‡å­—ä¹‹é—´çš„äº‹æƒ…äº†ï¼Œå®è´ã€‚æˆ‘ä»¬å¼€å§‹å§ï¼

æˆ‘ä»¬æ¥ä¸‹æ¥è¦æ·±å…¥ç ”ç©¶ä¸€äº›ä»£ç çš„æ›´æ”¹ã€‚ä»`/components/WorkspaceProvider.tsx`å¼€å§‹ã€‚

è¿™é‡Œåªæœ‰ä¸€äº›å°æ›´æ”¹ï¼Œä¸»è¦æ˜¯ä¸ºäº†å¼•å…¥`switchboard program`ã€‚

```tsx
const [switchboardProgram, setProgramSwitchboard] = useState<any>()
```

ç„¶åï¼Œæˆ‘ä»¬åŠ è½½`switchboard program`ï¼Œå¹¶ä½¿ç”¨`useEffect`è®¾ç½®`the program switchboard`ï¼Œç¡®ä¿æˆ‘ä»¬çš„å·¥ä½œåŒºå§‹ç»ˆèƒ½å¤ŸåŠæ—¶æ›´æ–°æ‰€æœ‰æ‰€éœ€ç¨‹åºã€‚è¿™å¯èƒ½ä¼šæ˜¯ä¸€ä¸ªæŒ‘æˆ˜ï¼Œé™¤éä½ æ˜¯Reactçš„ä¸“å®¶ï¼Œå¦åˆ™è¯·éšæ„æ·±å…¥ç ”ç©¶è¿™æ®µä»£ç ã€‚

```tsx
async function program() {
    let response = await loadSwitchboardProgram(
      "devnet",
      connection,
      ((provider as AnchorProvider).wallet as AnchorWallet).payer
    )
    return response
  }

useEffect(() => {
    program().then((result) => {
      setProgramSwitchboard(result)
      console.log("result", result)
    })
  }, [connection])
```

å¥½çš„ï¼Œæ¥ä¸‹æ¥æˆ‘ä»¬è¿›å…¥ `instructions.ts` æ–‡ä»¶å¤¹ä¸­çš„ `utils` æ–‡ä»¶ï¼Œè¿™æ˜¯ä¸€ä¸ªæ–°æ–‡ä»¶ã€‚è¿™é‡Œæœ‰ä¸¤ä¸ªå…¬å…±å‡½æ•°ï¼Œåˆ†åˆ«æ˜¯ `createOpenLootboxInstructions` æŒ‡ä»¤å’Œ `createInitSwitchboardInstructions` æŒ‡ä»¤ã€‚åè€…ç”¨äºæ‰“åŒ…äº¤æ¢æœºç¨‹åºçš„åˆå§‹åŒ–å†…å®¹ï¼Œå¹¶åˆå§‹åŒ–æŠ½å¥–ç®±ç¨‹åºä¸­çš„ç”¨æˆ·ã€‚

```tsx
export async function createOpenLootboxInstructions(
  connection: Connection,
  stakingProgram: Program<AnchorNftStaking>,
  switchboardProgram: SwitchboardProgram,
  lootboxProgram: Program<LootboxProgram>,
  userPubkey: PublicKey,
  nftTokenAccount: PublicKey,
  box: number
): Promise<TransactionInstruction[]> {
  const [userStatePda] = PublicKey.findProgramAddressSync(
    [userPubkey.toBytes()],
    lootboxProgram.programId
  )

  const state = await lootboxProgram.account.userState.fetch(userStatePda)

  const accounts = await getAccountsAndData(
    lootboxProgram,
    switchboardProgram,
    userPubkey,
    state.vrf
  )

  return await createAllOpenLootboxInstructions(
    connection,
    stakingProgram,
    lootboxProgram,
    switchboardProgram,
    accounts,
    nftTokenAccount,
    box
  )
}
```

è¿›ä¸€æ­¥å¾€ä¸‹ï¼Œæœ‰ä¸€ä¸ª `getAccountsAndData` å‡½æ•°ï¼Œå®ƒæ¥å—å››ä¸ªå­—æ®µï¼Œæ­£å¦‚ä½ æ‰€è§ï¼Œå¯¹äºæœ€åä¸€ä¸ªå­—æ®µï¼Œä½ éœ€è¦äº‹å…ˆç”Ÿæˆæˆ–è·å–`vrf`è´¦æˆ·ã€‚è¿™ä¸ªå‡½æ•°çš„ä½œç”¨æ˜¯è·å–ä¸€äº›è´¦æˆ·ã€å¢åŠ å’Œå…¶ä»–æ•°æ®ï¼Œå°†å®ƒä»¬æ‰“åŒ…èµ·æ¥ï¼Œå¹¶ä½œä¸ºä¸€ä¸ªå¯¹è±¡è¿”å›ã€‚

```tsx
async function getAccountsAndData(
  lootboxProgram: Program<LootboxProgram>,
  switchboardProgram: SwitchboardProgram,
  userPubkey: PublicKey,
  vrfAccount: PublicKey
): Promise<AccountsAndDataSuperset> {
  const [userStatePda] = PublicKey.findProgramAddressSync(
    [userPubkey.toBytes()],
    lootboxProgram.programId
  )

  // required switchboard accoount
  const [programStateAccount, stateBump] =
    ProgramStateAccount.fromSeed(switchboardProgram)

  // required switchboard accoount
  const queueAccount = new OracleQueueAccount({
    program: switchboardProgram,
    // devnet permissionless queue
    publicKey: new PublicKey("F8ce7MsckeZAbAGmxjJNetxYXQa9mKr9nnrC3qKubyYy"),
  })

  // required switchboard accoount
  const queueState = await queueAccount.loadData()
  // wrapped SOL is used to pay for switchboard VRF requests
  const wrappedSOLMint = await queueAccount.loadMint()

  // required switchboard accoount
  const [permissionAccount, permissionBump] = PermissionAccount.fromSeed(
    switchboardProgram,
    queueState.authority,
    queueAccount.publicKey,
    vrfAccount
  )

  // required switchboard accoount
  // escrow wrapped SOL token account owned by the VRF account we will initialize
  const escrow = await spl.getAssociatedTokenAddress(
    wrappedSOLMint.address,
    vrfAccount,
    true
  )

  const size = switchboardProgram.account.vrfAccountData.size

  return {
    userPubkey: userPubkey,
    userStatePda: userStatePda,
    vrfAccount: vrfAccount,
    escrow: escrow,
    wrappedSOLMint: wrappedSOLMint,
    programStateAccount: programStateAccount,
    stateBump: stateBump,
    permissionBump: permissionBump,
    queueAccount: queueAccount,
    queueState: queueState,
    permissionAccount: permissionAccount,
    size: size,
  }
}
```

è¯¥æ®µæè¿°äº†åœ¨æ–‡ä»¶åº•éƒ¨å®šä¹‰çš„ä¸€ä¸ªæ¥å£å¯¹è±¡ï¼Œè¿™ä¸»è¦æ˜¯ä¸ºäº†ç¡®ä¿ä½ æ‹¥æœ‰æ‰€éœ€çš„æ‰€æœ‰å†…å®¹ï¼Œå¹¶èƒ½å¤Ÿé€‚å½“åœ°è°ƒç”¨å®ƒä»¬ã€‚è¿™ä¸ªæ¥å£åŒ…æ‹¬äº†è®¸å¤šå…¬é’¥å’Œä¸ç¨‹åºçŠ¶æ€ã€æƒé™ç­‰æœ‰å…³çš„å­—æ®µã€‚

ä»¥ä¸‹æ˜¯æ¥å£çš„ä»£ç å®šä¹‰ï¼š

```tsx
interface AccountsAndDataSuperset {
  userPubkey: PublicKey
  userStatePda: PublicKey
  vrfAccount: PublicKey
  escrow: PublicKey
  wrappedSOLMint: spl.Mint
  programStateAccount: ProgramStateAccount
  stateBump: number
  permissionBump: number
  queueAccount: OracleQueueAccount
  queueState: any
  permissionAccount: PermissionAccount
  size: number
}
```

è¯¥æ®µè¿˜æ·±å…¥ä»‹ç»äº†`createInitSwitchboardInstructions`å‡½æ•°ã€‚è¿™ä¸ªå‡½æ•°é¦–å…ˆç”Ÿæˆä¸€ä¸ª`vrf`å¯†é’¥å¯¹ï¼Œç„¶åè°ƒç”¨`getAccountsAndData`ä»¥è·å–æ‰€æœ‰å¿…è¦çš„è´¦æˆ·ã€‚æ¥ç€ï¼Œé€šè¿‡`initSwitchboardLootboxUser`ï¼Œå®ƒç»„è£…äº†æŒ‡ä»¤ï¼Œå¹¶è¿”å›è¿™äº›æŒ‡ä»¤å’Œç”¨äºç­¾åçš„`vrf`å¯†é’¥å¯¹ã€‚

```tsx
export async function createInitSwitchboardInstructions(
  switchboardProgram: SwitchboardProgram,
  lootboxProgram: Program<LootboxProgram>,
  userPubkey: PublicKey
): Promise<{
  instructions: Array<TransactionInstruction>
  vrfKeypair: Keypair
}> {
  const vrfKeypair = Keypair.generate()

  const accounts = await getAccountsAndData(
    lootboxProgram,
    switchboardProgram,
    userPubkey,
    vrfKeypair.publicKey
  )

  const initInstructions = await initSwitchboardLootboxUser(
    switchboardProgram,
    lootboxProgram,
    accounts,
    vrfKeypair
  )

  return { instructions: initInstructions, vrfKeypair: vrfKeypair }
}
```

å…³äº `initSwitchboardLootboxUser` ï¼Œæˆ‘ä»¬é¦–å…ˆè·å¾—ä¸€ä¸ª`PDA`å’Œ`state bump`ã€‚

```tsx
async function initSwitchboardLootboxUser(
  switchboardProgram: SwitchboardProgram,
  lootboxProgram: Program<LootboxProgram>,
  accountsAndData: AccountsAndDataSuperset,
  vrfKeypair: Keypair
): Promise<Array<TransactionInstruction>> {
  // lootbox account PDA
  const [lootboxPointerPda] = await PublicKey.findProgramAddress(
    [Buffer.from("lootbox"), accountsAndData.userPubkey.toBytes()],
    lootboxProgram.programId
  )

  const stateBump = accountsAndData.stateBump
```

ç„¶åæˆ‘ä»¬å¼€å§‹ç»„è£…ä¸€ç³»åˆ—çš„æŒ‡ä»¤ã€‚é¦–å…ˆï¼Œæˆ‘ä»¬éœ€è¦åšçš„æ˜¯åˆ›å»ºä¸€ä¸ªä¸æ‰˜ç®¡ç›¸å…³çš„ä»¤ç‰Œè´¦æˆ·ï¼Œç”±`vrf`å¯†é’¥å¯¹æ‹¥æœ‰ã€‚

```tsx
const txnIxns: TransactionInstruction[] = [
    // create escrow ATA owned by VRF account
    spl.createAssociatedTokenAccountInstruction(
      accountsAndData.userPubkey,
      accountsAndData.escrow,
      vrfKeypair.publicKey,
      accountsAndData.wrappedSOLMint.address
    ),
```

æ¥ä¸‹æ¥æ˜¯è®¾ç½®æƒé™æŒ‡ä»¤ã€‚

```tsx
// transfer escrow ATA owner to switchboard programStateAccount
    spl.createSetAuthorityInstruction(
      accountsAndData.escrow,
      vrfKeypair.publicKey,
      spl.AuthorityType.AccountOwner,
      accountsAndData.programStateAccount.publicKey,
      [vrfKeypair]
    ),

```

ç„¶åæˆ‘ä»¬è°ƒç”¨`create account`æ¥åˆ›å»º`vrf`è´¦æˆ·ã€‚

```tsx
// request system program to create new account using newly generated keypair for VRF account
   SystemProgram.createAccount({
     fromPubkey: accountsAndData.userPubkey,
     newAccountPubkey: vrfKeypair.publicKey,
     space: accountsAndData.size,
     lamports:
       await switchboardProgram.provider.connection.getMinimumBalanceForRentExemption(
         accountsAndData.size
       ),
     programId: switchboardProgram.programId,
   }),
```

ç„¶åæˆ‘ä»¬ä½¿ç”¨`switchboard program `æ–¹æ³•è¿›è¡Œ`vrf`åˆå§‹åŒ–ï¼Œå…¶ä¸­æˆ‘ä»¬æä¾›äº†æ¶ˆè€—éšæœºæ€§å›è°ƒå‡½æ•°ã€‚

```tsx
// initialize new VRF account, included the callback CPI into lootbox program as instruction data
await switchboardProgram.methods
  .vrfInit({
    stateBump,
    callback: {
      programId: lootboxProgram.programId,
      accounts: [
        {
          pubkey: accountsAndData.userStatePda,
          isSigner: false,
          isWritable: true,
        },
        {
          pubkey: vrfKeypair.publicKey,
          isSigner: false,
          isWritable: false,
        },
        { pubkey: lootboxPointerPda, isSigner: false, isWritable: true },
        {
          pubkey: accountsAndData.userPubkey,
          isSigner: false,
          isWritable: false,
        },
      ],
      ixData: new BorshInstructionCoder(lootboxProgram.idl).encode(
        "consumeRandomness",
        ""
      ),
    },
  })
  .accounts({
    vrf: vrfKeypair.publicKey,
    escrow: accountsAndData.escrow,
    authority: accountsAndData.userStatePda,
    oracleQueue: accountsAndData.queueAccount.publicKey,
    programState: accountsAndData.programStateAccount.publicKey,
    tokenProgram: spl.TOKEN_PROGRAM_ID,
  })
  .instruction(),
// initialize switchboard permission account, required account
```

æ¥ä¸‹æ¥æˆ‘ä»¬ä½¿ç”¨`switchboard`æ¥è°ƒç”¨æƒé™åˆå§‹åŒ–ã€‚

```tsx
await switchboardProgram.methods
      .permissionInit({})
      .accounts({
        permission: accountsAndData.permissionAccount.publicKey,
        authority: accountsAndData.queueState.authority,
        granter: accountsAndData.queueAccount.publicKey,
        grantee: vrfKeypair.publicKey,
        payer: accountsAndData.userPubkey,
        systemProgram: SystemProgram.programId,
      })
      .instruction(),
```

æœ€åï¼Œæˆ‘ä»¬å°†æˆ‘ä»¬çš„æˆ˜åˆ©å“ç®±è®¡åˆ’ç§°ä¸º`init user`ï¼Œå¹¶è¿”å›æŒ‡ç¤ºï¼Œè¿™å°†ç”±è°ƒç”¨è€…æ‰“åŒ…æˆäº¤æ˜“ã€‚

```tsx
await lootboxProgram.methods
      .initUser({
        switchboardStateBump: accountsAndData.stateBump,
        vrfPermissionBump: accountsAndData.permissionBump,
      })
      .accounts({
        // state: userStatePDA,
        vrf: vrfKeypair.publicKey,
        // payer: publicKey,
        // systemProgram: anchor.web3.SystemProgram.programId,
      })
      .instruction(),
  ]

  return txnIxns
}
```

æœ€åï¼Œè®©æˆ‘ä»¬å›é¡¾ä¸€ä¸‹ `createOpenLootboxInstructions` ã€‚é¦–å…ˆï¼Œæˆ‘ä»¬è·å–ç”¨æˆ·çŠ¶æ€`PDA`ï¼Œæˆ‘ä»¬å¿…é¡»å®é™…è·å–è¯¥è´¦æˆ·ï¼Œä»¥ä¾¿æˆ‘ä»¬å¯ä»¥ä»ä¸­æå–`vrf`å¯†é’¥å¯¹ã€‚

```tsx
export async function createOpenLootboxInstructions(
  connection: Connection,
  stakingProgram: Program<AnchorNftStaking>,
  switchboardProgram: SwitchboardProgram,
  lootboxProgram: Program<LootboxProgram>,
  userPubkey: PublicKey,
  nftTokenAccount: PublicKey,
  box: number
): Promise<TransactionInstruction[]> {
  const [userStatePda] = PublicKey.findProgramAddressSync(
    [userPubkey.toBytes()],
    lootboxProgram.programId
  )

  const state = await lootboxProgram.account.userState.fetch(userStatePda)
```

åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬ç§°ä¹‹ä¸º `getAccountsAndData` æ¥è·å–æˆ‘ä»¬æ‰€éœ€çš„æ‰€æœ‰è´¦æˆ·ã€‚æ¥ä¸‹æ¥æ˜¯ `createAllOpenLootboxInstructions` ï¼Œæˆ‘ä»¬å°†æ·±å…¥æ¢è®¨ã€‚

```tsx
const accounts = await getAccountsAndData(
    lootboxProgram,
    switchboardProgram,
    userPubkey,
    state.vrf
  )

  return await createAllOpenLootboxInstructions(
    connection,
    stakingProgram,
    lootboxProgram,
    switchboardProgram,
    accounts,
    nftTokenAccount,
    box
  )
}
```
æˆ‘ä»¬è·å¾—äº†åŒ…è£…çš„ä»£å¸è´¦æˆ·ï¼Œå…¶ä¸­åŒ…å«äº†åŒ…è£…çš„`SOL`ï¼Œå› ä¸ºè¿™æ˜¯æˆ‘ä»¬ç”¨æ¥æ”¯ä»˜è¯·æ±‚éšæœºæ•°çš„å¿…éœ€å“ã€‚



```tsx
async function createAllOpenLootboxInstructions(
  connection: Connection,
  stakingProgram: Program<AnchorNftStaking>,
  lootboxProgram: Program<LootboxProgram>,
  switchboardProgram: SwitchboardProgram,
  accountsAndData: AccountsAndDataSuperset,
  nftTokenAccount: PublicKey,
  box: number
): Promise<TransactionInstruction[]> {
  // user Wrapped SOL token account
  // wSOL amount is then transferred to escrow account to pay switchboard oracle for VRF request
  const wrappedTokenAccount = await spl.getAssociatedTokenAddress(
    accountsAndData.wrappedSOLMint.address,
    accountsAndData.userPubkey
  )
```

æ¥ä¸‹æ¥æˆ‘ä»¬è·å¾—ä¸`BLD`ç›¸å…³çš„ `stakeTokenAccount` ï¼Œå› æ­¤ä½ å¯ä»¥ä½¿ç”¨`BLD`ä»£å¸æ¥æ¢å–å¼€å¯æˆ˜åˆ©å“ç®±ã€‚ç„¶åæ˜¯è´¨æŠ¼è´¦æˆ·ï¼Œä»¥ç¡®ä¿ä½ é€šè¿‡è´¨æŠ¼è·å¾—è¶³å¤Ÿçš„`BLD`æ¥å¼€å¯æˆ˜åˆ©å“ç®±ã€‚

```tsx
// user BLD token account, used to pay BLD tokens to call the request randomness instruction on Lootbox program
  const stakeTokenAccount = await spl.getAssociatedTokenAddress(
    STAKE_MINT,
    accountsAndData.userPubkey
  )

  const [stakeAccount] = PublicKey.findProgramAddressSync(
    [accountsAndData.userPubkey.toBytes(), nftTokenAccount.toBuffer()],
    stakingProgram.programId
  )
```

è¿™é‡Œå¼€å§‹ç»„è£…è¯´æ˜ã€‚å¦‚æœæ²¡æœ‰å°è£…çš„ä»¤ç‰Œè´¦æˆ·ï¼Œæˆ‘ä»¬ä¼šæ·»åŠ ä¸€ä¸ªåˆ›å»ºå®ƒçš„æŒ‡ä»¤ã€‚

```tsx
let instructions: TransactionInstruction[] = []
  // check if a wrapped SOL token account exists, if not add instruction to create one
  const account = await connection.getAccountInfo(wrappedTokenAccount)
  if (!account) {
    instructions.push(
      spl.createAssociatedTokenAccountInstruction(
        accountsAndData.userPubkey,
        wrappedTokenAccount,
        accountsAndData.userPubkey,
        accountsAndData.wrappedSOLMint.address
      )
    )
  }
```

ç„¶åæˆ‘ä»¬æ¨é€ä¸€ä¸ªè½¬è´¦æŒ‡ä»¤ï¼Œå°†`SOL`è½¬ç§»åˆ°`wrapped SOL`ã€‚ç„¶åæ˜¯ä¸€ä¸ªåŒæ­¥`wrapped SOL`ä½™é¢çš„æŒ‡ä»¤ã€‚

```tsx
// transfer SOL to user's own wSOL token account
 instructions.push(
   SystemProgram.transfer({
     fromPubkey: accountsAndData.userPubkey,
     toPubkey: wrappedTokenAccount,
     lamports: 0.002 * LAMPORTS_PER_SOL,
   })
 )
 // sync wrapped SOL balance
 instructions.push(spl.createSyncNativeInstruction(wrappedTokenAccount))
```

æœ€åï¼Œæˆ‘ä»¬åˆ¶ä½œå¹¶è¿”å›äº†æ‰“å¼€æˆ˜åˆ©å“ç®±çš„è¯´æ˜ä¹¦ï¼Œè¿™æ ·å‘¼å«è€…å°±å¯ä»¥å°†å®ƒä»¬æ‰“åŒ…å¹¶å‘é€å‡ºå»ã€‚

```tsx
// Lootbox program request randomness instruction
  instructions.push(
    await lootboxProgram.methods
      .openLootbox(new BN(box))
      .accounts({
        user: accountsAndData.userPubkey,
        stakeMint: STAKE_MINT,
        stakeMintAta: stakeTokenAccount,
        stakeState: stakeAccount,
        state: accountsAndData.userStatePda,
        vrf: accountsAndData.vrfAccount,
        oracleQueue: accountsAndData.queueAccount.publicKey,
        queueAuthority: accountsAndData.queueState.authority,
        dataBuffer: accountsAndData.queueState.dataBuffer,
        permission: accountsAndData.permissionAccount.publicKey,
        escrow: accountsAndData.escrow,
        programState: accountsAndData.programStateAccount.publicKey,
        switchboardProgram: switchboardProgram.programId,
        payerWallet: wrappedTokenAccount,
        recentBlockhashes: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
      })
      .instruction()
  )

  return instructions
}
```

è¿™å°±æ˜¯è¯´æ˜çš„å…¨éƒ¨å†…å®¹ï¼Œè®©æˆ‘ä»¬å»çœ‹çœ‹æ–°çš„æˆ˜åˆ©å“ç®±ç»„ä»¶ï¼Œè¿™äº›è¯´æ˜å°†ä¼šè¢«ç”¨åˆ°é‚£é‡Œã€‚
